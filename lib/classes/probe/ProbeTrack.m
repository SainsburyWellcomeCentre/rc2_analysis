classdef ProbeTrack < handle
% ProbeTrack Class for handling information in the track.csv generated
% after brainreg_segment or brainglobe_segmentation
%
%   ProbeTrack Properties:
%       offset              - a value in um about how much to offset
%                               boundaries +ve means boundaries shift up relative to probe
%       tbl                 - a MATLAB table containing the data in the .csv
%       probe               - instance of class Probe
%       from_probe_tip      - distance of each point in the table from the probe tip in um
%       region_id           - region ID (Allen CCF) of each point in the
%                             table
%       region_str          - region acronym (Allen CCF) of each point in
%                             the table
%
%   ProbeTrack Methods:
%       region_boundaries               - get boundaries of each region along the probe
%       region_boundaries_adjusted      - get boundaries of each region after offset is applied
%       get_region_of_point_from_tip    - given a point from the probe tip,
%                                         get the region in which that point exists
%       get_region_of_point_from_tip_adjusted - given a point from the
%                                               probe tip, get the region in which that point exists after
%                                               accounting for shift of the boundaries
%       mid_l5_visp                     - 
%       get_pia_from_tip                - 
%       get_pia_from_tip_adjusted       - 
%       get_region_relative_depth       - 
%       get_region_relative_depth_adjusted - 
%       
%
%   Offset...
%

    properties
        
        offset = 0  % offset compared to electrophysiology
    end
    
    properties (Hidden = true, SetAccess = private)
        
        tbl
        probe
    end
    
    properties (Dependent = true)
        
        from_probe_tip
        region_id
        region_str
    end
    
    
    
    methods
        
        function obj = ProbeTrack(tbl, probe_type)
        % ProbeTrack
        %
        %   ProbeTrack(TABLE, PROBE_TYPE)
        %   class for handling information contained in the probe track file
        %   generated by brainreg_segment.
        %   TABLE is the MATLAB table acquired by loading the track file
        %   (track_0.csv, track_1.csv etc) with 'readtable'
        %   PROBE_TYPE is the type of probe either '3A' or '24' 
        %
        %   Can apply an offset on the boundaries
        %       
        
        
            VariableDefault('probe_type', '3A');
            
            obj.tbl = tbl;
            obj.probe = Probe(probe_type);
        end
        
        
        
        function val = get.from_probe_tip(obj)
        %%for each point in the probe track table get the distance from the
        %   probe tip, not accounting for the electrophysiology offset
            if any("Position" == string(obj.tbl.Properties.VariableNames))
                % for brainreg_segment
                val = obj.tbl.Position(end) - obj.tbl.Position;
            elseif any("Index" == string(obj.tbl.Properties.VariableNames))
                % for braingloble_segmentation
                val = obj.tbl.Index(end) - obj.tbl.Index;
            end
        end
        
        
        
        function val = get.region_id(obj)
        %%region id at each mm of the probe track
        %   converts any NaN values into a numeric value -10
            val = obj.tbl.RegionID;
            val(isnan(val)) = -10;
        end
        
        
        
        function val = get.region_str(obj)
        %%region str at each mm of the probe track
            val = obj.tbl.RegionAcronym;
        end
        
        
        
        function [boundaries, region_id, region_str] = region_boundaries(obj)
        %%region_boundaries Get boundaries of each region along the probe
        %
        %   [BOUNDARIES, REGION_ID, REGION_STR] = region_boundaries()
        %   return where on the probe the region boundaries occur
        %   as well as the region strings for those boundaries
        %   without any correction for the electrophysiology
        %   
        %   Outputs:
        %       BOUNDARIES - 1x(N+1) vector containing the distance of a region
        %                   bounday from the probe tip in um, where N is
        %                   the number of regions in the probe track file
        %       REGION_ID - 1xN vector containing the (Allen) region ID
        %                   jth entry is region ID between boundary j and
        %                   j+1
        %       REGION_STR - 1xN cell array containing the (Allen) region acronym
        %                   jth entry is region ID between boundary j and
        %                   j+1
        %
        %   See also: region_boundaries_adjusted
        
            % find where the region IDs change
            idx = find(abs(diff(obj.region_id)) > 0);
            
            boundaries = obj.from_probe_tip([1, idx(:)'+1, end]);
            region_id = obj.region_id([1, idx(:)'+1]);
            region_str = obj.region_str([1, idx(:)'+1]);
        end
        
        
        
        function [boundaries, region_id, region_str] = region_boundaries_adjusted(obj)
        %%region_boundaries_adjusted Get boundaries of each region along the probe
        %
        %   [BOUNDARIES, REGION_ID, REGION_STR] = region_boundaries_adjusted()
        %   return region boundaries relative to probe tip after correction for
        %   the difference between the position of high-frequency power peak and
        %   anatomy mid-L5.
        %
        %   See also: region_boundaries
        
            [boundaries, region_id, region_str] = obj.region_boundaries();
            boundaries = boundaries + obj.offset;
        end
        
        
        
        function [region_id, region_str, from_pia] = get_region_of_point_from_tip(obj, from_tip)
        %%get_region_of_point_from_tip Given a point from the probe tip, get the region in which that point exists
        %
        %   [REGION_ID, REGION_STR, FROM_PIA] = get_region_of_point_from_tip(FROM_TIP)
        %   for a point FROM_TIP microns from the probe tip, get the region ID (REGION_ID), 
        %   region acronym (REGION_STR) and distance from pia (FROM_PIA) of
        %   that point.
        %
        %   See also: get_region_of_point_from_tip_adjusted
        
            [region_id, region_str, from_pia] = obj.region_from_tip_shared(from_tip, 0);
        end
        
        
        
        function [region_id, region_str, from_pia] = get_region_of_point_from_tip_adjusted(obj, from_tip)
        %%get_region_of_point_from_tip_adjusted Given a point from the probe tip, get the region in which that point exists
        %
        %   [REGION_ID, REGION_STR, FROM_PIA] = get_region_of_point_from_tip_adjusted(FROM_TIP)
        %   for a point FROM_TIP microns from the probe tip, get the region ID (REGION_ID), 
        %   region acronym (REGION_STR) and distance from pia (FROM_PIA) of
        %   that point after correction for
        %   the difference between the position of high-frequency power peak and
        %   anatomy mid-L5.
        %
        %   See also: get_region_of_point_from_tip
            
            [region_id, region_str, from_pia] = obj.region_from_tip_shared(from_tip, obj.offset);
        end
        
        
        
        function [region_id, region_str, from_pia] = region_from_tip_shared(obj, from_tip, offset)
        %%region_from_tip_shared Called by both
        %%get_region_of_point_from_tip and get_region_of_point_from_tip_adjusted
        %
        %   [REGION_ID, REGION_STR, FROM_PIA] = region_from_tip_shared(FROM_TIP, OFFSET) 
        %   for a point FROM_TIP microns from the probe tip, get the region ID (REGION_ID), 
        %   region acronym (REGION_STR) and distance from pia (FROM_PIA) of
        %   that point after shifting the boundaries of the regions by
        %   OFFSET um.
        
            pia_from_tip = obj.get_pia_from_tip + offset;
            from_pia = pia_from_tip - from_tip;
            
            if from_pia < 0
                region_id = -10;
                region_str = 'Not found in brain';
            elseif from_tip < offset
                region_id = -11;
                region_str = 'Beyond tracked region';
            else
                % get closest point
                [~, idx] = min(abs(from_tip - (obj.from_probe_tip + offset)));
                % return region ID and region acronym
                region_id = obj.region_id(idx);
                region_str = obj.region_str{idx};
            end
        end
        
        
        
        function val = mid_l5_visp(obj)
        %%mid_l5_visp Get distance of mid layer 5 (VISp5) from the probe tip before any
        %   correction for electrophysiology L5 peak
        %
        %   DISTANCE = mid_l5_visp()
        
            [boundaries, ~, region_str] = obj.region_boundaries(); %#ok<*PROP>
            
            idx = find(strcmp(region_str, 'VISp5'));
            
            if length(idx) == 1 && ~ismember(idx, [1, length(region_str)])
                val = mean(boundaries([idx, idx+1]));
            else
                % one mouse in which boundaries run across VISpm and VISp
                val = nan;
            end
        end
        
        
        
        function val = get_pia_from_tip(obj)
        %%get_pia_from_tip Get the distance of the pia from the probe tip
        %
        %   DISTANCE = get_pia_from_tip()  return the distance of the pial surface from the probe tip
        %   
        %   *NOTE* to determine pial surface this function looks for regions of
        %   the form VISp*1.
        %
        %   See also: get_pia_from_tip_adjusted
        
            [boundaries, ~, regions] = obj.region_boundaries();
            visp1_cmp =  regexp(regions, 'VISp*\w1');
            visp1_idx = cellfun(@(x)(~isempty(x)), visp1_cmp);
            val = boundaries(visp1_idx);
        end
        
        
        
        function val = get_pia_from_tip_adjusted(obj)
        %%get_pia_from_tip_adjusted Get the distance of the pia from the
        %%probe tip after accounting for shift of the boundaries
        %
        %   DISTANCE = get_pia_from_tip()  return the distance of the pial surface from the probe tip
        %   after correction for the difference between the position of high-frequency power peak and
        %   anatomy mid-L5.
        %   
        %   *NOTE* to determine pial surface this function looks for regions of
        %   the form VISp*1.
        %
        %   See also: get_pia_from_tip
        
            val = obj.get_pia_from_tip();
            val = val + obj.offset;
        end
        
        
        
        function val = get_region_relative_depth(obj, from_tip)
        %%get_region_relative_depth Get relative depth in a region for a
        %%point on the probe
        %
        %   RELATIVE_DEPTH = get_region_relative_depth(FROM_TIP) 
        %   For a point on the probe, FROM_TIP, first get the region in
        %   which the point exists and then calcuate the relative depth in
        %   that region of the point. RELATIVE_DEPTH is a value between 0
        %   (on top boundary) and 1 (on bottom boundary).
        %
        %   See also: get_region_relative_depth_adjusted
        
            region_id = obj.get_region_of_point_from_tip(from_tip); %#ok<*PROPLC>
            [boundaries, region_ids] = obj.region_boundaries();
            
            val = obj.relative_depth_shared(from_tip, boundaries, region_ids, region_id);
        end
        
        
        
        function val = get_region_relative_depth_adjusted(obj, from_tip)
        %%get_region_relative_depth_adjusted Get relative depth in a region for a
        %%point on the probe after accounting for shift of the boundaries
        %
        %   RELATIVE_DEPTH = get_region_relative_depth_adjusted(FROM_TIP) 
        %   For a point on the probe, FROM_TIP, first get the region in
        %   which the point exists and then calcuate the relative depth in
        %   that region of the point. RELATIVE_DEPTH is a value between 0
        %   (on top boundary) and 1 (on bottom boundary). Similar to
        %   `get_region_relative_depth` but accounts for the difference
        %   between the position of high-frequency power peak and 
        %   anatomy mid-L5.
        %
        %   See also: get_region_relative_depth
        
            region_id = obj.get_region_of_point_from_tip_adjusted(from_tip); %#ok<*PROPLC>
            [boundaries, region_ids] = obj.region_boundaries_adjusted();
            
            val = obj.relative_depth_shared(from_tip, boundaries, region_ids, region_id);
        end
        
        
        
        function val = relative_depth_shared(obj, from_tip, boundaries, region_ids, region_id)
        %%relative_depth_shared Computes relative depth of point in a region.
        %
        %   RELATIVE_DEPTH = relative_depth_shared(FROM_TIP, BOUNDARIES, REGION_IDS, REGION_ID)
        %
        %       Inputs:
        %           FROM_TIP - point from probe tip of interest
        %           BOUNDARIES - list of region boundaries from probe tip
        %           REGION_IDS - list of region IDs associated with BOUNDARIES
        %           REGION_ID - ID of the region in which point exists
        
            idx = find(region_ids == region_id);
            if length(idx) ~= 1
                val = nan; return
            end
            
            upper = boundaries(idx);
            lower = boundaries(idx+1);
            
            val = (upper - from_tip) / (upper - lower);
        end
    end
end
