classdef Loader < handle
% Loader Class for helping with loading different types of data on the
% system
%
%  Loader Properties:
%    file_manager                -  instance of class FileManager
%
%  Loader Methods:
%    rc2_bin                     - load .bin for a RC2 session
%    camera_csv                  - load .csv containing camera motion energy for a session
%    camera0_dlc_pupil           - load a .csv containing tracking data of the pupil
%    camera0_saccades            - load a .csv containing frame numbers of saccade onsets
%    formatted_data              - load .mat containing formatted data for a probe recording
%    load_from_formatted_data    - load a specific variable(s) from the formatted data .mat file
%    experiment_list             - load the .csv "experiment list" file
%    svm_table                   - load the .csv file containing summary information about the 
%                                  stationary and motion periods for a probe recording
%    offsets_table               - load the .csv file containing sample offsets for replay trials for a probe recording
%    tuning_curves               - load the .mat file containing tuning curves for the clusters in a probe recording
%    track_csv                   - load the .csv containing information about the probe shanks and their placement in the brain
%    track_offset                - load the .txt file containing the offset between electrophysiological and anatomical L5 for a shank
%    ks2_npy                     - load one of the many .npy files in the Kilosort directory
%    cluster_groups              - load the .csv file containing information about clusters, i.e. whether they are 'good' or 'noise'
%    ks2_label                   - load the cluster_KSLabel.tsv file generated by ecephys_spike_sorting
%    trigger_mat                 - load the .mat file containing the sync trigger for a probe recording
%    params                      - load the params.py file generated by Kilosort
%    metrics_csv                 - load the metrics.csv file geneterated by ecephys_spike_sorting
%    waveform_metrics_csv        - load the waveform_metrics.csv file generated by ecephys_spike_sorting
%    waveform_metrics_fixed_csv  - load the waveform_metrics_fix.csv file with waveforms
%    clusters_janelia_xlsx       - load the .xlsx file saved after manual inspection of the data
%    mua_clusters_janelia_xlsx   - load the .xlsx file saved after manual inspection of the MUA data
%    selected_clusters           - load the selected_clusters.txt, list of selected clusters
%    selected_mua_clusters       - load the selected_mua_clusters.txt, list of selected clusters for MUA analysis
%    spikeglx_ap_metadata        - load the metadata for a SpikeGLX recording for a probe ID
%    spikeglx_ap_recording       - load an interface to the raw data of a SpikeGLX recording
%    
%Static:
%    readtable                   - general function for reading .csv
%    loadmat                     - general function for reading .mat
%    readnpy                     - general function for reading .npy
%
%   TODO:  1. link to locations with more information about the structures
%               being loaded
%          2. several methods need to cope with the event that a file does exist

    properties (SetAccess = private)
        
        file_manager
    end
    
    
    methods
        
        function obj = Loader(file_manager)
        %%Loader
        %
        %   Loader(FILE_MANAGER) where FILE_MANAGER is an object of class
        %   FileManager and controls information about path and file
        %   names on the current setup.
        
            obj.file_manager = file_manager;
        end
        
        
        
        function [data, dt, chan_names, config] = rc2_bin(obj, session_id)
        %%rc2_bin Load .bin for a RC2 session
        %
        %   [DATA, DT, CHAN_NAMES, CONFIG] = rc2_bin(SESSION_ID) 
        %   loads the data saved in a RC2 .bin file for the session with
        %   ID, SESSION_ID.
        %
        %   Outputs:
        %     DATA          - N x (# channels) matrix with N sample points data
        %     DT            - time difference between sample points in seconds
        %     CHAN_NAMES    - names given to the channels
        %     CONFIG        - full configuration structure in the .cfg associated with the .bin
        %
        %   If a .bin file can't be found for SESSION_ID all outputs are empty arrays.
        
            [fname, exists] = obj.file_manager.rc2_bin(session_id);
            if exists
                [data, dt, chan_names, config] = read_rc2_bin(fname);
            else
                data = []; dt = []; chan_names = []; config = [];
            end
        end
        
        
        
        function motion_energy = camera_csv(obj, session_id, camera_id)
        %%camera_csv Load .csv containing camera motion energy for a session
        %
        %   MOTION_ENERGY = camera_csv(SESSION_ID, CAMERA_ID) 
        %   loads the .csv containing motion energy for a session with
        %   ID, SESSION_ID. The CAMERA_ID should also be supplied
        %
        %   Outputs:
        %     MOTION_ENERGY - N x 1 vector of motion energies for N camera frames
        %
        %   If a .csv file can't be found for SESSION_ID and CAMERA_ID, MOTION_ENERGY is empty.
        
            [fname, exist] = obj.file_manager.camera_csv_fast(session_id, camera_id);
            if ~exist
                [fname, exist] = obj.file_manager.camera_csv_slow(session_id, camera_id);
            end
            if ~exist
                motion_energy = [];
                return
            end
            tbl = obj.readtable(fname);
            motion_energy = tbl.Var1;
        end
        
        
        
        function dlc_table = camera0_dlc_pupil(obj, session_id)
        %%camera0_dlc_pupil Load a .csv containing tracking data of the pupil for
        %%a session
        %
        %   DLC_TABLE = camera0_dlc_pupil(SESSION_ID) 
        %   loads the .csv containing pupil tracking data from DeepLabCut
        %   for a session with ID, SESSION_ID.
        %
        %   Outputs:
        %     DLC_TABLE - MATLAB table with the columns of the .csv. The
        %                 exact format of the table will differ and depend
        %                 on how DLC was run.
        %
        %   If a .csv file can't be found for SESSION_ID, DLC_TABLE is
        %   empty. 
        
            [fname, exist] = obj.file_manager.camera0_dlc_pupil_fast(session_id);
            if ~exist
                [fname, exist] = obj.file_manager.camera0_dlc_pupil_slow(session_id);
            end
            
            if ~exist
                dlc_table = [];
                return
            end
            
            dlc_table = obj.readtable(fname);
        end
        
        
        function diameter = pupil_diameter(obj, session_id)
        %TODO
            [fname, exist] = obj.file_manager.pupil_diameter_slow(session_id);
            if ~exist
                [fname, exist] = obj.file_manager.pupil_diameter_slow(session_id);
            end
            
            if ~exist
                diameter = [];
                return
            end
            
            dlc_table = obj.readtable(fname);
            diameter = dlc_table.Var1;
        end
        
        
        function saccade_table = camera0_saccades(obj, session_id)
        %%camera0_saccades Load a .csv containing tracking data of the pupil for
        %%a session
        %
        %   SACCADE_TABLE = camera0_saccades(SESSION_ID) 
        %   loads the .csv containing frames number of which saccades
        %   occurred (onset) along with the direction of the saccade
        %   ('nasal' or 'temporal') for a session with ID, SESSION_ID.
        %
        %   Outputs:
        %     SACCADE_TABLE - MATLAB table with the columns of the .csv,
        %                     which are currently 'saccade_frame', the
        %                     camera frame on which the saccade occurred
        %                     and 'direction' which indicates the direction
        %                     of the saccade.
        %
        %   If a .csv file can't be found for SESSION_ID, SACCADE_TABLE is
        %   empty.
        
            [fname, exist] = obj.file_manager.camera0_saccades_fast(session_id);
            if ~exist
                [fname, exist] = obj.file_manager.camera0_saccades_slow(session_id);
            end
            
            if ~exist
                saccade_table = [];
                return
            end
            
            saccade_table = obj.readtable(fname);
        end
        
        
        
        function data = formatted_data(obj, probe_id)
        %%formatted_data Load .mat containing formatted data for a probe recording
        %
        %   DATA = formatted_data(PROBE_ID)
        %   loads the .mat containing the formatted data for a probe
        %   recording with ID, PROBE_ID
        %
        %   Outputs:
        %     DATA -    structure containing the data for a probe recording.
        %
        %   If a .mat file can't be found for PROBE_ID, DATA is empty.
        %
        %   Note: to see more information about the structure returned see XX
        
            fname = obj.file_manager.formatted_data(probe_id);
            data = obj.loadmat(fname);
        end
        
        
        
        function data = load_from_formatted_data(obj, probe_id, var)
        %%load_from_formatted_data Load a specific variable(s) from the formatted data .mat file
        %
        %   DATA = load_from_formatted_data(PROBE_ID, VARIABLES)
        %   loads variables from the .mat containing the formatted data for a probe
        %   recording with ID, PROBE_ID. VARIABLES be either a
        %   string or a cell array of strings, with names equal to the
        %   variables stored in the .mat file. Currently, allowable
        %   variable names are:
        %       'anatomy', 'clusters', 'n_triggers', 'probe_id',
        %       'selected_clusters', and 'sessions'
        %
        %   Outputs:
        %     DATA -    structure containing specific variables for the data for a probe recording.
        %
        %   See also: formatted_data
        %
        %   TODO: return empty data upon error conditions.
        
            if ~iscell(var)
                var = {var};
            end
            fname = obj.file_manager.formatted_data(probe_id);
            data = load(fname, var{:});
        end
        
        
        
        function e_list = experiment_list(obj)
        %%experiment_list Load the .csv "experiment list" file
        %
        %   TABLE = experiment_list()
        %   loads the .csv containing the experiment_list (see main README)
        %   and returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.experiment_list();
            e_list = obj.readtable(fname);
        end
        
        
        
        function tbl = svm_table(obj, probe_id)
        %%svm_table Load the .csv file containing summary information about the 
        %%stationary and motion periods for a probe recording
        %
        %   TABLE = svm_table(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.svm_table(probe_id);
            tbl = obj.readtable(fname);
        end
        
        
        
        function tbl = offsets_table(obj, probe_id)
        %%offsets_table Load the .csv file containing sample offsets for replay trials for a probe recording
        %
        %   TABLE = offsets_table(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.offsets_table(probe_id);
            tbl = obj.readtable(fname);
        end
        
        
        
        function tuning_curves = tuning_curves(obj, probe_id)
        %%tuning_curves Load the .mat file containing tuning curves for the clusters in a probe recording
        %
        %   STRUCT = tuning_curves(PROBE_ID)
        %   loads the .mat for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB structure, STRUCT.
        %   
        %   See XX for more information about tuning curve data.
        
            fname = obj.file_manager.tuning_curves(probe_id);
            tuning_curves = load(fname, 'trial_groups', 'tuning_curves');
        end
        
        function tuning_curves = tuning_curves_acceleration(obj, probe_id)
        %%TODO
        
            fname = obj.file_manager.tuning_curves_acceleration(probe_id);
            tuning_curves = load(fname, 'trial_groups', 'tuning_curves');
        end
        
        
        function track = track_csv(obj, probe_id, shank_id)
        %%track_csv Load the .csv containing information about the probe shanks and their placement in the brain
        %
        %   TABLE = track_csv(PROBE_ID, SHANK_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and shank
        %   ID, SHANK_ID.  SHANK_ID is an integer (zero-indexed) indicating
        %   which shank of the probe to load. Probe/anatomical information is
        %   returned as a MATLAB table, TABLE.
        
            fname = obj.file_manager.track_csv(probe_id, shank_id);
            warning('off', 'MATLAB:table:ModifiedAndSavedVarnames');
            track = obj.readtable(fname);
            warning('on', 'MATLAB:table:ModifiedAndSavedVarnames');
        end
        
        
        
        function offset = track_offset(obj, probe_id, shank_id)
        %%track_offset Load the .txt file containing the offset between electrophysiological and anatomical L5 for a shank
        %
        %   VALUE = track_csv(PROBE_ID, SHANK_ID)
        %   loads the .txt for probe recording with ID, PROBE_ID and shank
        %   ID, SHANK_ID.  SHANK_ID is an integer (zero-indexed) indicating
        %   which shank of the probe to load. The offset is returned in a 
        
            [fname, exists] = obj.file_manager.track_offset(probe_id, shank_id);
            
            offset = [];
            if exists
                fid = fopen(fname, 'r');
                offset = textscan(fid, '%f%[^\n\r]');
                offset = offset{1};
                fclose(fid);
            end
        end
        
        
        
        function val = ks2_npy(obj, probe_id, var)
         %%ks2_npy Load one of the many .npy files in the Kilosort output directory
        %
        %   DATA = ks2_npy(PROBE_ID, VARIABLES)
        %   loads data from a .npy in the Kilosort output directory.
        %   VARIABES is a string with the name of one of these files.
        %
        %   Outputs:
        %     DATA -   matrix, with size depending on the file
        %              being loaded.
        %
        %   See XX for more information on those files.
        
            fname = obj.file_manager.ks2_npy(probe_id, var);
            val = obj.readnpy(fname);
        end
        
        
        
        function tbl = cluster_groups(obj, probe_id)
        %%cluster_groups Load the .csv file containing information about clusters, i.e. whether they are 'good' or 'noise'
        %
        %   TABLE = cluster_groups(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.cluster_groups(probe_id);
            tbl = obj.readtable(fname);
        end
        
        
        
        function tbl = ks2_label(obj, probe_id)
        %%ks2_label Load the cluster_KSLabel.tsv file generated by ecephys_spike_sorting
        %
        %   TABLE = ks2_label(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.ks2_label(probe_id);
            tbl = [];
            if isfile(fname)
                tbl = readtable(fname, 'FileType', "delimitedtext");
            end
        end
        
        
        
        function trigger = trigger_mat(obj, probe_id)
        %%trigger_mat Load the .mat file containing the sync trigger for a probe recording
        %
        %   TRIGGER = trigger_mat(PROBE_ID)
        %   loads the .mat for probe recording with ID, PROBE_ID and
        %   returns it as a Nx1 of values indicating the trigger state
        %   where N is the number of samples of the probe recording.
        
            fname = obj.file_manager.trigger_mat(probe_id);
            mat = obj.loadmat(fname);
            trigger = mat.trigger;
        end
        
        
        
        function data = params(obj, probe_id)
        %%params Load the params.py file generated by Kilosort
        %
        %   STRUCT = params(PROBE_ID)
        %   loads the .py for probe recording with ID, PROBE_ID and
        %   returns it as a structure, STRUCT, with all the elements in the
        %   .py file.
        
            [fname, exists] = obj.file_manager.params(probe_id);
            
            data = []; 
            
            if ~exists; return; end
            
            format_spec = '%s%s%s%[^\n\r]';
            fid = fopen(fname,'r');
            text_str = textscan(fid, format_spec, inf, ...
                'delimiter', ' ', ...
                'multipledelimsasone', true, ...
                'texttype', 'string', ...
                'headerlines', 0, ...
                'returnonerror', false, ...
                'endofline', '\r\n');
            
            for i = 1 : length(text_str{1})
                data.(text_str{1}{i}) = text_str{3}{i};
            end
            
            data.n_channels_dat     = str2double(data.n_channels_dat);
            data.offset             = str2double(data.offset);
            data.sample_rate        = str2double(data.sample_rate);
            
            fclose(fid);
        end
        
        
        
        function tbl = metrics_csv(obj, probe_id)
        %%metrics_csv Load the metrics.csv file geneterated by ecephys_spike_sorting
        %
        %   TABLE = metrics_csv(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.metrics_csv(probe_id);
            tbl = obj.readtable(fname);
        end
        
        
        
        function tbl = waveform_metrics_csv(obj, probe_id)
        %%waveform_metrics_csv Load the waveform_metrics.csv file generated by ecephys_spike_sorting
        %
        %   TABLE = waveform_metrics_csv(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.waveform_metrics_csv(probe_id);
            tbl = obj.readtable(fname);
        end
        
        
        
        function tbl = waveform_metrics_fixed_csv(obj, probe_id)
        %%waveform_metrics_fixed_csv Load the waveform_metrics_fix.csv file with waveforms
        %
        %   TABLE = waveform_metrics_fixed_csv(PROBE_ID)
        %   loads the .csv for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
            
            fname = obj.file_manager.waveform_metrics_fixed_csv(probe_id);
            tbl = obj.readtable(fname);
        end
        
        
        
        function tbl = clusters_janelia_xlsx(obj, probe_id)
        %%clusters_janelia_xlsx Load the .xlsx file saved after manual inspection of the data
        %
        %   TABLE = clusters_janelia_xlsx(PROBE_ID)
        %   loads the .xlsx for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.clusters_janelia_xlsx(probe_id);
            tbl = readtable(fname);
        end
        
        
        
        function tbl = mua_clusters_janelia_xlsx(obj, probe_id)
        %%mua_clusters_janelia_xlsx Load the .xlsx file saved after manual
        %%inspection of the MUA data 
        %
        %   TABLE = mua_clusters_janelia_xlsx(PROBE_ID)
        %   loads the .xlsx for probe recording with ID, PROBE_ID and
        %   returns it as a MATLAB table, TABLE.
        
            fname = obj.file_manager.mua_clusters_janelia_xlsx(probe_id);
            tbl = readtable(fname);
        end
        
        
        
        function cluster_ids = selected_clusters(obj, probe_id)
        %%selected_clusters Load the selected_clusters.txt, list of selected clusters
        %
        %   LIST = selected_clusters(PROBE_ID)
        %   loads the .txt for probe recording with ID, PROBE_ID and
        %   returns a list of clusters as a N x 1 array LIST, with the
        %   selected cluster IDs.
        
            fname = obj.file_manager.selected_clusters_txt(probe_id);
            
            cluster_ids = [];
            
            if isfile(fname)
                
                format_spec = '%f%[^\n\r]';
                fid = fopen(fname, 'r');
                data = textscan(fid, format_spec, ...
                    'texttype', 'string', ...
                    'headerlines', 0, ...
                    'returnonerror', false);
                fclose(fid);
                cluster_ids = data{1};
            end
        end
        
        
        
        function cluster_ids = selected_mua_clusters(obj, probe_id)
        %%selected_mua_clusters Load the selected_mua_clusters.txt, list of
        %%selected MUA clusters 
        %
        %   LIST = selected_mua_clusters(PROBE_ID)
        %   loads the .txt for probe recording with ID, PROBE_ID and
        %   returns a list of clusters as a N x 1 array LIST, with the
        %   selected cluster IDs.
        %
        %   If there is no such file, then LIST is an empty array.
        
            fname = obj.file_manager.selected_mua_clusters_txt(probe_id);
            
            cluster_ids = [];
            
            if isfile(fname)
                
                format_spec = '%f%[^\n\r]';
                fid = fopen(fname, 'r');
                data = textscan(fid, format_spec, ...
                    'texttype', 'string', ...
                    'headerlines', 0, ...
                    'returnonerror', false);
                fclose(fid);
                cluster_ids = data{1};
            end
        end
        
        
        
        function meta = spikeglx_ap_metadata(obj, probe_id)
        %%spikeglx_ap_metadata Load the metadata for a SpikeGLX recording for a probe ID
        %
        %   META = spikeglx_ap_metadata(PROBE_ID)
        %   loads the .meta file for a SpikeGLX recording for probe
        %   recording with ID, PROBE ID. Information is returned as an
        %   object of class SpikeGLXMetaData allowing access to all the fields contained in the .meta file.
        %
        %   See also: SpikeGLXMetaData, SpikeGLXRecording
        
            % search first for fast, then for slow drives
            [dname, exists] = obj.file_manager.glx_bin_dir_processed_fast(probe_id);
            
            if ~exists
                [dname, exists] = obj.file_manager.glx_bin_dir_processed_slow(probe_id);
            end
            
            if ~exists
                meta = [];
                return
            end
            
            meta = SpikeGLXMetaData(dname, 'ap');
        end
        
        
        
        function rec = spikeglx_ap_recording(obj, probe_id)
        %%spikeglx_ap_recording Load an interface to the raw data of a SpikeGLX recording
        %
        %   META = spikeglx_ap_recording(PROBE_ID)
        %   loads the .meta and .bin file for a SpikeGLX recording for probe
        %   recording with ID, PROBE ID. Information is returned as an
        %   object of class SpikeGLXRecording allowing access to all data
        %   in the SpikeGLX recording.
        %
        %   See also: SpikeGLXMetaData, SpikeGLXRecording
        
            % search first for fast, then for slow drives
            [dname, exists] = obj.file_manager.glx_bin_dir_processed_fast(probe_id);
            
            if ~exists
                [dname, exists] = obj.file_manager.glx_bin_dir_processed_slow(probe_id);
            end
            
            if ~exists
                rec = [];
                return
            end
            
            rec = SpikeGLXRecording(dname, 'ap');
        end
    end
    
    
    
    methods (Static = true)
        
        function tbl = readtable(fname)
        %%readtable General function for reading .csv
        
            tbl = [];
            if isfile(fname)
                tbl = readtable(fname);
            end
        end
        
        
        
        function struct = loadmat(fname)
        %%loadmat General function for reading .mat
        
            struct = [];
            if isfile(fname)
                struct = load(fname);
            end
        end
        
        
        
        function val = readnpy(fname)
        %%readnpy General function for reading .npy
        
            val = [];
            if isfile(fname)
                val = readNPY(fname);
            end
        end
    end
end
